package de.uni_mannheim.informatik.dws.melt.matching_jena_matchers.util.addnegatives;

import com.googlecode.cqengine.query.QueryFactory;
import de.uni_mannheim.informatik.dws.melt.matching_base.AddNegatives;
import de.uni_mannheim.informatik.dws.melt.matching_base.IMatcherCaller;
import de.uni_mannheim.informatik.dws.melt.matching_base.typetransformer.AlignmentAndParameters;
import de.uni_mannheim.informatik.dws.melt.matching_base.typetransformer.GenericMatcherCaller;
import de.uni_mannheim.informatik.dws.melt.matching_base.typetransformer.TypeTransformerRegistry;
import de.uni_mannheim.informatik.dws.melt.matching_jena.MatcherYAAAJena;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Alignment;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Correspondence;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.CorrespondenceRelation;
import java.util.Properties;
import java.util.Set;
import org.apache.jena.ontology.OntModel;

/**
 * This component adds negative correspondences to the input alignment via a recall optimized matcher.
 * This also means that the input alignment should contain positive correspondences.
 * After applying the recallMatcher given in the constructor, a new alignment is returned which
 * contains positive (equivalence relation) and negative(incompat relation) correspondences.
 * With the help of this alignment, supervised matchers can be trained. 
 */
public class AddNegativesViaMatcher extends MatcherYAAAJena implements IMatcherCaller, AddNegatives {


    private final Object recallMatcher;
    
    /**
     * Constructor with requires the recall matcher
     * @param recallMatcher this matcher should return many (even wrong) correspondences.
     */
    public AddNegativesViaMatcher(Object recallMatcher){
        this.recallMatcher = recallMatcher;
    }
    
    @Override
    public AlignmentAndParameters match(Set<Object> sourceRepresentations, Set<Object> targetRepresentations, Object inputAlignment, Object parameters) throws Exception {
        AlignmentAndParameters r = GenericMatcherCaller.runMatcherMultipleRepresentations(this.recallMatcher, sourceRepresentations, targetRepresentations, null, parameters);
        
        Alignment recallAlignment = r.getAlignment(Alignment.class, TypeTransformerRegistry.getTransformedPropertiesOrNewInstance(parameters));        
        Alignment referenceAlignment = TypeTransformerRegistry.getTransformedObjectOrNewInstance(inputAlignment, Alignment.class, parameters);
        
        Alignment training = addNegatives(recallAlignment, referenceAlignment);
        
        return new AlignmentAndParameters(training, r.getParameters());
    }
    
    @Override
    public Alignment match(OntModel source, OntModel target, Alignment inputAlignment, Properties parameters) throws Exception {
        AlignmentAndParameters r = GenericMatcherCaller.runMatcher(this.recallMatcher, source, target, null, parameters);
        Alignment recallAlignment = r.getAlignment(Alignment.class, TypeTransformerRegistry.getTransformedPropertiesOrNewInstance(parameters));         
        return addNegatives(recallAlignment, inputAlignment);
    }

    /**
     * This method returns a training alignment based on a recall alignment and a reference alignment.
     * The training alignment is generated by getting all correspondences in the recall alignment where at least one
     * part is also contained in the reference alignment.
     * If the correspondence is directly in the reference alignment, then it is assumed to be a positive example.
     * If only one part of the correspondence is in the reference alignment, then is is assumed to be a negative
     * correspondence.
     * The result contains the correspondences from the recall alignment, where positive examples have the equivalence
     * relation and negative examples have INCOMPAT relation.
     * @param recallAlignment recall alignment
     * @param referenceAlignment reference alignment which does not need to really be the reference alignment of a track.
     * @return the correspondences from the recall alignment, where positive examples have the equivalence relation and negative examples have INCOMPAT relation
     */
    public static Alignment addNegatives(Alignment recallAlignment, Alignment referenceAlignment){
        
        //generate the training examples
        Iterable<Correspondence> alternatives = recallAlignment.retrieve(
                QueryFactory.and(
                    QueryFactory.or(
                        QueryFactory.in(Correspondence.SOURCE, referenceAlignment.getDistinctSourcesAsSet()),
                        QueryFactory.in(Correspondence.TARGET, referenceAlignment.getDistinctTargetsAsSet())
                    ),
                    QueryFactory.equal(Correspondence.RELATION, CorrespondenceRelation.EQUIVALENCE)
                )
        );
        
        Alignment trainingAlignment = new Alignment();
        for(Correspondence c : alternatives) {
            if(referenceAlignment.contains(c)) {
                trainingAlignment.add(
                        new Correspondence(c.getEntityOne(), c.getEntityTwo(), c.getConfidence(), CorrespondenceRelation.EQUIVALENCE, c.getExtensions())
                );
            } else {
                trainingAlignment.add(
                        new Correspondence(c.getEntityOne(), c.getEntityTwo(), c.getConfidence(), CorrespondenceRelation.INCOMPAT, c.getExtensions())
                );
            }
        }
        return trainingAlignment;
    }
}
