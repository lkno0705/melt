package de.uni_mannheim.informatik.dws.melt.matching_ml.python.nlptransformers;

import de.uni_mannheim.informatik.dws.melt.matching_base.FileUtil;
import de.uni_mannheim.informatik.dws.melt.matching_base.Filter;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Alignment;
import de.uni_mannheim.informatik.dws.melt.yet_another_alignment_api.Correspondence;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.rdf.model.Resource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import de.uni_mannheim.informatik.dws.melt.matching_jena.TextExtractor;
import de.uni_mannheim.informatik.dws.melt.matching_ml.python.PythonServer;
import java.io.IOException;

/**
 * This filter extracts the corresponding text for a resource (with the specified and customizable extractor) given all correspondences in the input alignment.
 * The texts of the two resources are fed into the specified transformer model and the prediction is added in form of a confidence to the correspondence.
 * No filtering is applied in this class.
 */
public class TransformersFilter extends TransformersBase implements Filter {


    private static final Logger LOGGER = LoggerFactory.getLogger(TransformersFilter.class);
    private static final String NEWLINE = System.getProperty("line.separator");
    
    private boolean changeClass;

    /**
     * Constructor with all required parameters and default values for optional parameters (can be changed by setters).
     * It uses the systems default tmp dir to store the files with texts generated from the knowledge graphs.
     * Pytorch is used instead of tensorflow and all visible GPUs are used for prediction.
     * @param extractor the extractor to select which text for each resource should be used.
     * @param modelName the model name which can be a model id (a hosted model on huggingface.co) or a path to a directory containing a model and tokenizer
     * (<a href="https://huggingface.co/transformers/main_classes/model.html#transformers.PreTrainedModel.from_pretrained">
     * see first parameter pretrained_model_name_or_path of the from_pretrained
     * function in huggingface library</a>). In case of a path, it should be absolute. 
     * The path can be generated by e.g. {@link FileUtil#getCanonicalPathIfPossible(java.io.File) }
     */
    public TransformersFilter(TextExtractor extractor, String modelName) {
        super(extractor, modelName);
        this.changeClass = false;
    }
    
    @Override
    public Alignment match(OntModel source, OntModel target, Alignment inputAlignment, Properties properties) throws Exception{
        File inputFile = FileUtil.createFileWithRandomNumber(this.tmpDir, "alignment_transformers_predict", ".txt");
        List<Correspondence> orderedCorrespondences = new ArrayList<>();
        LOGGER.info("Write text to prediction file {}", inputFile);
        try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(inputFile), StandardCharsets.UTF_8))){
            for(Correspondence c : inputAlignment){
                String left = getTextFromResource(source.getResource(c.getEntityOne()));
                String right = getTextFromResource(target.getResource(c.getEntityTwo()));
                if(StringUtils.isBlank(left) || StringUtils.isBlank(right)){
                    //setting to 0 if not existing
                    c.addAdditionalConfidence(this.getClass(), 0.0);
                    continue;
                }
                orderedCorrespondences.add(c);
                writer.write(StringEscapeUtils.escapeCsv(left) + "," + StringEscapeUtils.escapeCsv(right) + NEWLINE);
            }
        } catch (IOException ex) {
            LOGGER.warn("Could not write text to prediction file. Return unmodified input alignment.", ex);
            inputFile.delete();
            return inputAlignment;
        }
        
        if(orderedCorrespondences.isEmpty()){
            LOGGER.warn("No correspondences have enough text to be processed (the input alignment has {} " +
                    "correspondences) - the input alignment is returned unchanged.", inputAlignment.size());
            inputFile.delete();
            return inputAlignment;
        }

        try {
            LOGGER.info("Run prediction for {} examples ({} correspondences do not have enough text to be processed).",
                    orderedCorrespondences.size(), inputAlignment.size() - orderedCorrespondences.size());
            List<Double> confidenceList = predictConfidences(inputFile);
            LOGGER.info("Finished prediction");

            if(orderedCorrespondences.size() != confidenceList.size()){
                LOGGER.warn("Size of correspondences and predictions do not have the same size. Return input alignment.");
                return inputAlignment;
            }
            for(int i=0; i < orderedCorrespondences.size(); i++){
                orderedCorrespondences.get(i).addAdditionalConfidence(this.getClass(), confidenceList.get(i));
            }
        } finally {
            inputFile.delete();
        }
        return inputAlignment;
    }
    
    /**
     * Create the prediction file which is a CSV file with two columns.
     * The first column is the text from the left resource and the second column is the text from the right resource.
     * @param source The source model
     * @param target The target model
     * @param trainingAlignment the alignment to process. All correspondences are used.
     * @return the prediction file (CSV formatted)
     * @throws IOException in case the writing fails.
     */
    public File createPredictionFile(OntModel source, OntModel target, Alignment trainingAlignment) throws IOException {
        File file = FileUtil.createFileWithRandomNumber(this.tmpDir, "alignment_transformers_predict", ".txt");
        createPredictionFile(source, target, trainingAlignment, file, false);
        return file;
    }

    /**
     * Create the prediction file which is a CSV file with two columns.
     * The first column is the text from the left resource and the second column is the text from the right resource.
     * @param source The source model
     * @param target The target model
     * @param trainingAlignment the alignment to process. All correspondences are used.
     * @param outputFile the csv file to which the output should be written to.
     * @param append if true, then the training alignment is append to the given file.
     * @throws IOException in case the writing fails.
     */
    public void createPredictionFile(OntModel source, OntModel target, Alignment trainingAlignment, File outputFile, boolean append) throws IOException {
        LOGGER.info("Write text to prediction file {}", outputFile);
        try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile, append), StandardCharsets.UTF_8))){
            for(Correspondence c : trainingAlignment){
                String left = getTextFromResource(source.getResource(c.getEntityOne()));
                String right = getTextFromResource(target.getResource(c.getEntityTwo()));
                if(StringUtils.isBlank(left) || StringUtils.isBlank(right)){
                    continue;
                }
                writer.write(StringEscapeUtils.escapeCsv(left) + "," + StringEscapeUtils.escapeCsv(right) + NEWLINE);
            }
        }
    }
    
    private String getTextFromResource(Resource r){
        StringBuilder sb = new StringBuilder();
        for(String text : this.extractor.extract(r)){
            sb.append(text.trim()).append(" ");
        }
        return sb.toString().trim();
    }
    
    /**
     * Run huggingface transformers library.
     * @param predictionFilePath path to csv file with two columns (text left and text right).
     * @throws Exception in case something goes wrong.
     * @return a list of confidences
     */
    public List<Double> predictConfidences(File predictionFilePath) throws Exception{
        return PythonServer.getInstance().transformersPrediction(this, predictionFilePath);
    }

    //setter and getter

    public boolean isChangeClass() {
        return changeClass;
    }

    public void setChangeClass(boolean changeClass) {
        this.changeClass = changeClass;
    }
}
